import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.Random; // For peer ID generation

// --- TorrentMessage (simplified for this example) ---
// class TorrentMessage {
    public enum Type {
        CHOKE(0),
        UNCHOKE(1),
        INTERESTED(2),
        NOT_INTERESTED(3),
        HAVE(4),
        BITFIELD(5),
        REQUEST(6),
        PIECE(7),
        CANCEL(8),
        PORT(9), // For DHT Tracker
        KEEP_ALIVE(null); // Special case: length 0

        private final Integer id;

        Type(Integer id) {
            this.id = id;
        }

        public Integer getId() {
            return id;
        }

        public static Type fromId(int id) {
            for (Type type : values()) {
                if (type.id != null && type.id == id) {
                    return type;
                }
            }
            return null; // Unknown type
        }
    }

    private final Type type;
    private final byte[] payload; // For HAVE, BITFIELD, REQUEST, PIECE, CANCEL

    public TorrentMessage(Type type, byte[] payload) {
        this.type = type;
        this.payload = payload;
    }

    public Type getType() {
        return type;
    }

    public byte[] getPayload() {
        return payload;
    }

    public int getPieceIndex() { // For HAVE message
        if (type == Type.HAVE && payload != null && payload.length == 4) {
            return ByteBuffer.wrap(payload).getInt();
        }
        throw new IllegalStateException("Not a HAVE message or invalid payload");
    }
    
    public byte[] getBitfield() { // For BITFIELD message
        if (type == Type.BITFIELD) {
            return payload;
        }
        throw new IllegalStateException("Not a BITFIELD message");
    }


    // --- Static factory methods to create messages ---
    public static byte[] craftKeepAlive() {
        return new byte[]{0, 0, 0, 0}; // Length prefix 0
    }

    public static byte[] craftChoke() {
        return new byte[]{0, 0, 0, 1, (byte) Type.CHOKE.getId()};
    }

    public static byte[] craftUnchoke() {
        return new byte[]{0, 0, 0, 1, (byte) Type.UNCHOKE.getId()};
    }

    public static byte[] craftInterested() {
        return new byte[]{0, 0, 0, 1, (byte) Type.INTERESTED.getId()};
    }

    public static byte[] craftNotInterested() {
        return new byte[]{0, 0, 0, 1, (byte) Type.NOT_INTERESTED.getId()};
    }

    public static byte[] craftHave(int pieceIndex) {
        ByteBuffer buffer = ByteBuffer.allocate(4 + 1 + 4); // length_prefix + id + payload
        buffer.putInt(1 + 4); // message length (id + payload)
        buffer.put((byte) Type.HAVE.getId());
        buffer.putInt(pieceIndex);
        return buffer.array();
    }

    public static byte[] craftBitfield(byte[] bitfield) {
        ByteBuffer buffer = ByteBuffer.allocate(4 + 1 + bitfield.length);
        buffer.putInt(1 + bitfield.length);
        buffer.put((byte) Type.BITFIELD.getId());
        buffer.put(bitfield);
        return buffer.array();
    }
    
    @Override
    public String toString() {
        String payloadStr = "";
        if (payload != null) {
            if (type == Type.HAVE) {
                payloadStr = "pieceIndex=" + getPieceIndex();
            } else if (type == Type.BITFIELD) {
                payloadStr = "bitfield_len=" + payload.length;
            } else {
                payloadStr = "payload_len=" + payload.length;
            }
        }
        return "TorrentMessage{type=" + type + ", " + payloadStr + "}";
    }
}

// --- Peer class (enhanced) ---
class Peer {
    private final String host;
    private final int port;
    private Socket socket;
    private DataInputStream inputStream;
    private DataOutputStream outputStream;

    private static final int CONNECT_TIMEOUT_MS = 5000; // 5 seconds
    private static final int READ_TIMEOUT_MS = 10000;    // 10 seconds for general reads
    private static final int HANDSHAKE_READ_TIMEOUT_MS = 10000; // 10 seconds for handshake read

    public static final String PSTR = "BitTorrent protocol";
    public static final int HANDSHAKE_LENGTH = 1 + PSTR.length() + 8 + 20 + 20; // pstrlen + pstr + reserved + infohash + peerid

    public Peer(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public void connect() throws IOException {
        socket = new Socket();
        socket.connect(new InetSocketAddress(host, port), CONNECT_TIMEOUT_MS);
        // Set a general read timeout. Can be adjusted for specific operations.
        socket.setSoTimeout(READ_TIMEOUT_MS);
        outputStream = new DataOutputStream(socket.getOutputStream());
        inputStream = new DataInputStream(socket.getInputStream());
        System.out.println("Connected to " + host + ":" + port);
    }

    public void sendHandshake(byte[] infoHash, byte[] peerId) throws IOException {
        if (infoHash.length != 20 || peerId.length != 20) {
            throw new IllegalArgumentException("InfoHash and PeerID must be 20 bytes long.");
        }
        ByteBuffer handshakeBuffer = ByteBuffer.allocate(HANDSHAKE_LENGTH);
        handshakeBuffer.put((byte) PSTR.length());
        handshakeBuffer.put(PSTR.getBytes(StandardCharsets.ISO_8859_1));
        handshakeBuffer.put(new byte[8]); // 8 reserved bytes
        handshakeBuffer.put(infoHash);
        handshakeBuffer.put(peerId);

        outputStream.write(handshakeBuffer.array());
        outputStream.flush();
        System.out.println("Sent handshake to " + host + ":" + port);
    }

    public byte[] receiveHandshake(byte[] expectedInfoHash) throws IOException {
        socket.setSoTimeout(HANDSHAKE_READ_TIMEOUT_MS); // Specific timeout for handshake
        byte[] handshakeBytes = new byte[HANDSHAKE_LENGTH];
        try {
            inputStream.readFully(handshakeBytes);
        } finally {
            socket.setSoTimeout(READ_TIMEOUT_MS); // Reset to general read timeout
        }

        ByteBuffer buffer = ByteBuffer.wrap(handshakeBytes);
        byte pstrlen = buffer.get();
        if (pstrlen != PSTR.length()) {
            throw new IOException("Invalid pstrlen: " + pstrlen);
        }

        byte[] pstrBytes = new byte[pstrlen];
        buffer.get(pstrBytes);
        String receivedPstr = new String(pstrBytes, StandardCharsets.ISO_8859_1);
        if (!PSTR.equals(receivedPstr)) {
            throw new IOException("Invalid pstr: " + receivedPstr);
        }

        byte[] reserved = new byte[8]; // Skip reserved bytes
        buffer.get(reserved);

        byte[] receivedInfoHash = new byte[20];
        buffer.get(receivedInfoHash);
        if (!Arrays.equals(expectedInfoHash, receivedInfoHash)) {
            throw new IOException("InfoHash mismatch. Expected: " + bytesToHex(expectedInfoHash) +
                                  ", Got: " + bytesToHex(receivedInfoHash));
        }

        byte[] receivedPeerId = new byte[20];
        buffer.get(receivedPeerId);
        System.out.println("Received handshake from " + host + ":" + port + ", Peer ID: " + bytesToHex(receivedPeerId));
        return receivedPeerId;
    }

    public void sendMessage(byte[] message) throws IOException {
        outputStream.write(message);
        outputStream.flush();
    }

    public TorrentMessage receiveMessage() throws IOException {
        int length;
        try {
            length = inputStream.readInt(); // Reads 4 bytes
        } catch (SocketTimeoutException e) {
            // This is common if the peer is idle. We can treat it as a keep-alive opportunity.
            // Or simply return null to indicate no message within timeout.
            // System.out.println("Read timeout while waiting for message length from " + host + ":" + port);
            return null; // Indicate timeout
        } catch (EOFException e) {
            // Connection closed by peer
            System.out.println("Connection closed by peer (EOF) " + host + ":" + port);
            throw e;
        }


        if (length < 0) { // Should not happen with readInt unless stream corrupted
            throw new IOException("Invalid message length received: " + length);
        }
        if (length == 0) {
            return new TorrentMessage(TorrentMessage.Type.KEEP_ALIVE, null);
        }

        byte messageId = inputStream.readByte();
        TorrentMessage.Type type = TorrentMessage.Type.fromId(messageId);

        if (type == null) {
            System.err.println("Unknown message ID: " + messageId + " with length " + length + " from " + host + ":" + port);
            // Drain the rest of the message to not corrupt the stream for next read
            byte[] unknownPayload = new byte[length - 1];
            inputStream.readFully(unknownPayload);
            return null; // Or a special "UnknownMessage" type
        }
        
        int payloadLength = length - 1; // Subtract 1 for the message ID byte
        byte[] payload = null;
        if (payloadLength > 0) {
            payload = new byte[payloadLength];
            inputStream.readFully(payload);
        } else if (payloadLength < 0) {
             throw new IOException("Message length " + length + " too short for message ID " + messageId);
        }
        
        return new TorrentMessage(type, payload);
    }


    public void close() {
        System.out.println("Closing connection with " + host + ":" + port);
        try {
            if (inputStream != null) inputStream.close();
        } catch (IOException e) { /* ignore */ }
        try {
            if (outputStream != null) outputStream.close();
        } catch (IOException e) { /* ignore */ }
        try {
            if (socket != null) socket.close();
        } catch (IOException e) { /* ignore */ }
    }

    // Helper to convert byte array to hex string for logging
    public static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}

// --- Main Application ---
public class TorrentClientPeerComm {

    // Replace with your actual info_hash and generate a peer_id
    // Example: SHA1 hash of the "info" dictionary from a .torrent file
    // For testing, you can use a known public torrent's info_hash.
    // This info_hash is for an Ubuntu ISO (you'll need a live torrent for this to work)
    static final byte[] infoHashGlobal = Peer.bytesToHex("232422c244e500890696978822596060310512c7"); // Example
    static final byte[] peerIdGlobal = generatePeerId(); // Should be unique per client instance

    private static byte[] generatePeerId() {
        // Standard peer ID format: -AZ2060- followed by 12 random digits/chars
        // e.g., "-TR2940-" (Transmission) or "-UT355S-" (uTorrent)
        Random random = new Random();
        byte[] peerId = new byte[20];
        System.arraycopy("-MY0001-".getBytes(StandardCharsets.ISO_8859_1), 0, peerId, 0, 8);
        for (int i = 8; i < 20; i++) {
            peerId[i] = (byte) (random.nextInt(26) + 'a'); // random lowercase letters
        }
        return peerId;
    }


    public static void main(String[] args) {
        // Peers list (replace with peers obtained from a tracker)
        // You'll need actual BitTorrent peers that are part of the swarm for infoHashGlobal
        List<Peer> peers = List.of(
                // new Peer("127.0.0.1", 6881) // Example for local testing if you run a client
                 new Peer("router.bittorrent.com", 6881), // DHT bootstrap node, might not do full peer protocol
                 new Peer("dht.transmissionbt.com", 6881) // Another DHT bootstrap
                // Add real peers from a tracker for the specific infoHashGlobal
                // For example, a peer for the Ubuntu torrent might be "90.154.120.43", 51413 (this will vary)
        );
        
        if (infoHashGlobal.length != 20 || peerIdGlobal.length != 20) {
            System.err.println("Error: infoHashGlobal and peerIdGlobal must be 20 bytes long.");
            System.err.println("Current infoHashGlobal length: " + infoHashGlobal.length);
            System.err.println("Current peerIdGlobal length: " + peerIdGlobal.length);
            return;
        }
        System.out.println("Using Peer ID: " + new String(peerIdGlobal, StandardCharsets.ISO_8859_1) + " (" + Peer.bytesToHex(peerIdGlobal) + ")");
        System.out.println("Using Info Hash: " + Peer.bytesToHex(infoHashGlobal));


        for (Peer peer : peers) {
            System.out.println("\nAttempting to connect to: " + peer.getHost() + ":" + peer.getPort());
            try {
                // 1) Open the TCP connection with timeouts
                peer.connect();

                // 2) Send our 68‑byte handshake
                peer.sendHandshake(infoHashGlobal, peerIdGlobal);

                // 3) Read & verify their handshake (throws if infoHash mismatches)
                byte[] remotePeerId = peer.receiveHandshake(infoHashGlobal);
                // System.out.println("Remote peer ID: " + Peer.bytesToHex(remotePeerId));

                System.out.println("Handshake OK with " + peer.getHost() + ":" + peer.getPort());

                // 4) Send an "interested" message
                peer.sendMessage(TorrentMessage.craftInterested());
                System.out.println("Sent INTERESTED to " + peer.getHost() + ":" + peer.getPort());

                // 5) Attempt to read a few messages from the peer
                int messagesToRead = 5; // Let's try to read up to 5 messages or until timeout
                int messagesRead = 0;
                long lastMessageTime = System.currentTimeMillis();
                // Keep-alive messages should be sent if no messages are sent/received for ~2 minutes.
                // Here, we are just expecting messages from the peer for a short duration.
                final long MAX_WAIT_FOR_MESSAGES_MS = 20000; // Wait up to 20s total for these initial messages

                while (messagesRead < messagesToRead && (System.currentTimeMillis() - lastMessageTime) < MAX_WAIT_FOR_MESSAGES_MS) {
                    System.out.println("Waiting for message from " + peer.getHost() + ":" + peer.getPort() + "...");
                    TorrentMessage receivedMsg = peer.receiveMessage(); // This uses the socket's read timeout

                    if (receivedMsg != null) {
                        lastMessageTime = System.currentTimeMillis(); // Reset timer on successful message
                        messagesRead++;
                        System.out.println("Received from " + peer.getHost() + ":" + peer.getPort() + " -> " + receivedMsg);

                        switch (receivedMsg.getType()) {
                            case KEEP_ALIVE:
                                System.out.println("   It's a KEEP_ALIVE.");
                                // No action needed other than acknowledging it reset any peer-side timeout.
                                break;
                            case BITFIELD:
                                System.out.println("   It's a BITFIELD. Length: " + receivedMsg.getBitfield().length);
                                // TODO: Process the bitfield (e.g. store it)
                                // For now, just print a snippet if it's small
                                if (receivedMsg.getBitfield().length < 20) {
                                    System.out.println("   Bitfield data (hex): " + Peer.bytesToHex(receivedMsg.getBitfield()));
                                }
                                break;
                            case CHOKE:
                                System.out.println("   Peer is CHOKING us. We cannot request pieces yet.");
                                break;
                            case UNCHOKE:
                                System.out.println("   Peer is UNCHOKING us. We can now request pieces (if we have their bitfield).");
                                break;
                            case HAVE:
                                System.out.println("   Peer HAS piece: " + receivedMsg.getPieceIndex());
                                // TODO: Update peer's known pieces
                                break;
                            case PIECE:
                                System.out.println("  Peer sent PIECE (unexpected in this simple loop unless we requested it).");
                                break;
                            // Other cases: INTERESTED, NOT_INTERESTED, REQUEST, CANCEL, PORT
                            default:
                                System.out.println("   Unhandled message type: " + receivedMsg.getType());
                                break;
                        }
                    } else {
                        // receiveMessage returned null, likely due to read timeout
                        System.out.println("No message received within specific read timeout from " + peer.getHost() + ":" + peer.getPort());
                        // We could send a keep-alive here if we were implementing a longer-lived connection
                        // peer.sendMessage(TorrentMessage.craftKeepAlive());
                        // For this example, we'll just let the outer loop check its overall timeout
                    }
                }
                if(messagesRead == 0) {
                     System.out.println("No messages received from " + peer.getHost() + ":" + peer.getPort() + " after sending INTERESTED.");
                }


            } catch (SocketTimeoutException e) {
                System.err.println("Timeout with "
                        + peer.getHost() + ":" + peer.getPort() + " → " + e.getMessage());
            } catch (EOFException e) {
                System.err.println("Connection closed unexpectedly by "
                        + peer.getHost() + ":" + peer.getPort() + " → " + e.getMessage());
            }
            catch (IOException e) {
                System.err.println("Communication error with "
                        + peer.getHost() + ":" + peer.getPort() + " → " + e.getClass().getSimpleName() + ": " + e.getMessage());
            } finally {
                peer.close(); // Ensure the connection is closed
            }
        }
        System.out.println("\nFinished attempting communication with all peers.");
    }
}